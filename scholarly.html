<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Malware OWL</title>
	<link rel="stylesheet" href="scholary.css" />
	<style>
	pre
	{
		font-family: Courier, 'New Courier', monospace;
		line-height: 1.2;
		font-size: 12px;
		
		white-space: pre-wrap;
		white-space: -moz-pre-wrap;
		white-space: -o-pre-wrap;
		word-wrap: break-word;
	}
	</style>
</head>
<body schema="http://schema.org/" xsd="http://www.w3.org/2001/XMLSchema sa="https://ns.science.ai/" >
	<article typeof="schema:ScholarlyArticle" resource="#">
		<h1>Malware OWL</h1>
		<section>
			<ol>
			  <!-- The first author, Robin Berjon -->
			  <li property="schema:author" typeof="sa:ContributorRole">
				<a property="schema:author" href="http://github.com/pdan93" typeof="schema:Person">
				  <span property="schema:givenName">Daniel</span>
				  <span property="schema:familyName">Popescu</span>
				</a>
				<a href="#scienceai" property="sa:roleAffiliation" resource="http://github.com/pdan93">a</a>
				<sup property="sa:roleContactPoint" typeof="schema:ContactPoint">
				  <a property="schema:email" href="mailto:danielpopescu93@gmail.com" title="corresponding author">✉</a>
				</sup>
			  </li>
			  <!-- The first author, Robin Berjon -->
			  <li property="schema:author" typeof="sa:ContributorRole">
				<a property="schema:author" href="http://github.com/citeaalexandru" typeof="schema:Person">
				  <span property="schema:givenName">Alexandru</span>
				  <span property="schema:familyName">Citea</span>
				</a>
				<a href="#scienceai" property="sa:roleAffiliation" resource="http://github.com/citeaalexandru">a</a>
				<sup property="sa:roleContactPoint" typeof="schema:ContactPoint">
				  <a property="schema:email" href="mailto:citeaalexandru@gmail.com " title="corresponding author">✉</a>
				</sup>
			  </li>
			</ol>
			<!-- The affiliation list -->
			<ol>
			  <li id="scienceai">
				<a href="http://info.uaic.ro" typeof="schema:Corporation">
				  <span property="schema:name">info.uaic.ro</span>
				</a>
			  </li>
			</ol>
		</section>
		<section typeof="sa:Abstract">
			<h2>Introduction</h2>
			<p>The Malware ontology project is meant to help in identifiyng similarities between malware files. Based on in-depth analysis from multiple sources, a complete characterization of the file is made and based on it different conclusions can be taken and meta informations can be constructed. With different levels of scopes available for comparation, a visual client to help malware analysists and a customized malware ontology, the MalwareOWL tries to be a helpful tool for specialists.</p>
		</section>
		<section typeof="sa:MaterialsAndMethods">
			<h2>Materials And Methods</h2>
			<p>A custom ontology is constructed for the project, using certain vocabulary elements from dbpedia, schema.org to define known concepts, the authors are defining a malware vocabulary that works in unison with the results from the file analysis. This will define the different categories of information as concepts so that when the connections between files are verrified entire areas of one can be matched.</p>
			<p>Using online api's and tools (VirusTotal, malwr.com, MalwareViz, Mastiff) as many properties as possible are processed about the file, each of them being connected in the malware ontology. VirusTotal offers 5 main categories of information: Analysis, File detail, Relationships, Additional Information and Behavioural information. These categories will be defined as resources/concepts inside the ontology and are also in turn composed of subcategories. (For example File detail: Packers identified, PE header basic information, PE sections, Overlays, PE imports, Nr of PE resources by type, PE resources). These subcategories together with new types of properties will sometime be new ones. Therefore the goal is to have them dinamically created inside the ontology and dinamically inserted inside the whole graph.</p>
		</section>
		<section>
			<h2>Challenges</h2>
			<section>
				<h3>Mapping the ontology dinamically</h3>
				<p>Because new properties on files may be found in any moment, and also for a more scalable project, the ontology needs to be easily editable instantly, with new triples being inserted in it when new vocabulary names or new file properties are found. Using SPARQL 1.1 will help in that aspect as it allows insertion of new data while the ontology is still active. The type of the property values is also an important aspect to be considered, and it should also be linked and defined for it. While both numerical and alphabetical values can be analized based on closeness to others, the way to do it is different and it may well end up being visible inside the application.</p>
			</section>
			<section>
				<h3>Separating the simmilarities</h3>
				<p>As long as they point to common concepts simmilarities can be found between any two files. We may end up with thousands of "similar" files. Therefore a limit must be set on the number of edges between two files and also, adding a second limit based on percentage (calculated on multiple properties common to the 2 files) increases the effectiveness of the application. This will be called the "sensibility" of the comparison and it will be a given parametter for all the API calls, and on the client it will convienently be displayed in the right down corner, as a slider with percentage values between 0-100%. The chosen value will mean the MIN percentage of simmilarities found between the 2 files.</p>
			</section>
			<section>
				<h3>Providing an API</h3>
				<p>The client for the application will use API endpoints to get the needed file properties, values and simmilarities. The API needs to transform requests into valid SPARQL interogations and then interpretate and convert the response. An OpenAPI specification is available <a href="https://pdan93.github.io/MalwareOWL/api_spec.html">here</a>. The main resource in the API is of course the hash of the file. This identifies it uniquely and helps in specifing the different scopes we want information for regarding it. For example calling API_URL/md5hash/Additional/FileIdentification/Filetype will return the value of the property "File type" for that md5. "Additional/FileIdentification/Filetype" also serves as the unique identificator for this property as well as a description of it's scope. </p>
			</section>
			
		</section>
		<section>
			<h2>Client Side application</h2>
			<p>On the client side, the application needs to be able to send requests on the file and present the results by constructing a visual graph. The different scopes are treated with the scrooling functionality. When a user goes with the mouse on a section and scrolls in, that section expands taking over the screeen and displays more information about it. This can be seen in the representation of the leveled scopes below.</p>
			<figure>
				<img src="viewer_level_1.png" />
				<caption>Whole scope view of the hash, simmilarities with some predefined big categories</caption>
			</figure>
			<figure>
				<img src="viewer_level_2.png" />
				<caption>Category scope view of the hash, minimum 70% similarities shown for each category.</caption>
			</figure>
			<figure>
				<img src="viewer_level_3.png" />
				<caption>Subcategory scope view of the hash, inside the file detail category, minimum 70% similarities shown for each subcategory.</caption>
			</figure>
			<figure>
				<img src="viewer_level_4.png" />
				<caption>Properties scope view of the hash inside FileDetail/FileVersionInfo/, minimum 70% similarities shown for each property.</caption>
			</figure>
			<figure>
				<img src="list.png" />
				<caption>Category level (FileDetail) view with list of hashes simmilar to the file.</caption>
			</figure>
			<figure>
				<img src="simmilar.png" />
				<caption>Side-by-side view of 2 hashes, at the subcategory level (FileDetail/FileVersionInfo/)</caption>
			</figure>
		</section>



		<section>
			<h2>Implementation details</h2>
			<section>
				<h3>Tooling</h3>
				<p>The toolset chosen for the job is straight forward:</p>
	                        <ul>
					<li>Backend: NodeJS - it offers a native implementation for asyncronious processing and takes advantage of the paralel capabilities of the server.</li>
					<li>Backend - scraping and file processing: Python - it offers a good variety of preimplemented libraries for data extraction and is quick to work with.</li>
					<li>Database: A Openlink Virtuoso server to host the linked data.
				</ul>
			</section>
			<section>
				<h3>Dinamically building the ontology</h3>
				<p>Mapping the various properties of the analysed files can be a hasle due to the vast quantity of information and sometimes their volatile nature. To overcome this problem, we used the following step sequence:</p>
				<ul>
					<li>We use a mapping script to scrape information sources and map them to a simple JSON parenting structure. Ex:</li>
					<pre>
{
	"behavioural-info": {
		"Read files": {
			"type": "array",
			"value": ["C:\\1d0dd2e04440836622dbb9655488655c1006a7c2407203d82c4e17f0bd838a32", 
				  "C:\\autoexec.bat", 
                                  "C:\\WINDOWS\\system32\\rsaenh.dll"]
		}
	},
	"additional-info": {
		"File identification": {
			"SHA1": {
				"type": "string",
				"value": "33b8ca3a078a20d7fa07b4b12f7909558ce65e71"
			}
			"MD5": {
				"type": "string",
				"value": "737a7c471130e9db6dbe19627d2dcd29"
			}
		}
	}
}
					</pre>
					<li>From this structure, we can extract the following class and instance model. Legend: -> (classes), ==> (instances) <br/>
					    The file we scanned is going to be mapped as an instance of a predefined class called File, which inherits owl:Thing.
					</li>
					<pre>
owl:Thing
	-> File
		==> 737a7c471130e9db6dbe19627d2dcd29 
	-> behavioural-info
		-> read_files
			==> C:\\1d0dd2e04440836622dbb9655488655c1006a7c2407203d82c4e17f0bd838a32
			==> C:\\autoexec.bat
			==> C:\\WINDOWS\\system32\\rsaenh.dll
	-> additional-info
		-> file_identification
			-> SHA1
				==> 33b8ca3a078a20d7fa07b4b12f7909558ce65e71
					</pre>
					<li>Also, each of those classed will be the base for building object properties that have the Domain on mowl:File and the range on the specific type of entity we want to point to. <br/>
					    Example: subject: mowl:File  --->   property:  mowl:has_additional_info_file_identification_sha1  ----->  value: mowl:33b8ca3a078a20d7fa07b4b12f7909558ce65e71 
					</li>
					
					
				</ul>
			</section>


			<section>
				<h3>SPARQL query analysis</h3>
				<p>There are multiple ways to construct the querys we need for our application. As an example, one of the more time consuming querys that needed to be constructed was
				   the one in charge of identifying the similarity quantity of the scanned file with other files. To be able to accomplish this, we had to match the number of identical properties from a specific
			           subcategory between each pair of files. A sample query to do the job would be:
				</p>
				<pre>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX mowl: <http://www.semanticweb.org/acitea/ontologies/2017/0/malware-ontology#>
SELECT ?md5_2 (COUNT (DISTINCT ?entity) AS ?count_general) 
              (COUNT (DISTINCT ?entity1) AS ?count_hash1)
              (COUNT (DISTINCT ?entity2) AS ?count_hash2)
WHERE {
    mowl:a449c20441b64398e8fad3121daf2757     ?prop    ?entity . 
    ?md5_2     ?prop    ?entity .
    ?md5_2     rdf:type     mowl:File  .
    FILTER(?entity != owl:NamedIndividual) .
    FILTER(?md5_2  != mowl:a449c20441b64398e8fad3121daf2757) .
    
    {
            ?entity             rdf:type   mowl:<property_category> 
    }
    UNION
    {
            ?entity             rdf:type            ?entity_subtype .
            ?entity_subtype     rdfs:subClassOf     mowl:<property_category>         
    }
    UNION
    {
            ?entity             rdf:type            ?entity_type .
            ?entity_type        rdfs:subClassOf     ?entity_subtype .
            ?entity_subtype     rdfs:subClassOf     mowl:<property_category>
    }
    UNION
    { 
            ?entity                 rdf:type            ?entity_type .
            ?entity_type            rdfs:subClassOf     ?entity_subtype .
            ?entity_subtype         rdfs:subClassOf     ?entity_subsubtype .
            ?entity_subsubtype      rdfs:subClassOf     mowl:<property_category>
    } .


    mowl:a449c20441b64398e8fad3121daf2757   ?prop1    ?entity1 .
    {
            ?entity1             rdf:type   mowl:<property_category> 
    }
    UNION
    {
            ?entity1             rdf:type            ?entity1_subtype .
            ?entity1_subtype     rdfs:subClassOf     mowl:<property_category>         
    }
    UNION
    {
            ?entity1             rdf:type            ?entity1_type .
            ?entity1_type        rdfs:subClassOf     ?entity1_subtype .
            ?entity1_subtype     rdfs:subClassOf     mowl:<property_category>
    }
    UNION
    { 
            ?entity1                 rdf:type            ?entity1_type .
            ?entity1_type            rdfs:subClassOf     ?entity1_subtype .
            ?entity1_subtype         rdfs:subClassOf     ?entity1_subsubtype .
            ?entity1_subsubtype      rdfs:subClassOf     mowl:<property_category>
    } .


    ?md5_2   ?prop2    ?entity2 .
    {
            ?entity2             rdf:type   mowl:<property_category> 
    }
    UNION
    {
            ?entity2             rdf:type            ?entity2_subtype .
            ?entity2_subtype     rdfs:subClassOf     mowl:<property_category>         
    }
    UNION
    {
            ?entity2             rdf:type            ?entity2_type .
            ?entity2_type        rdfs:subClassOf     ?entity2_subtype .
            ?entity2_subtype     rdfs:subClassOf     mowl:<property_category>
    }
    UNION
    { 
            ?entity2                 rdf:type            ?entity2_type .
            ?entity2_type            rdfs:subClassOf     ?entity2_subtype .
            ?entity2_subtype         rdfs:subClassOf     ?entity2_subsubtype .
            ?entity2_subsubtype      rdfs:subClassOf     mowl:<property_category>
    } 
}
GROUP BY ?md5_2
				</pre>
				<p>The unions are necesary to be able to match properties on multiple levels of depth. <br/>
				   Performance wise, this is a very slow query due to it's format. On a test sample of 3 files in the database with ~200 properties, the query takes about 6 seconds to run. On a test of 14 samples, ~1 minute.
				</p>
				<p>To be able to improve upon the execution time of the queries, we will take advantage of the paralel nature of NodeJS and the fact that each query for the Sparql database runs on a separate thread. <br/>
				   <figure>
					<img src="viewer_level_5.png" />
					<caption>Request handling.</caption>
				   </figure>
				   In order to paralelize the request, we must split the initial query into multiple smaller ones:
				   	<ul>
						<li>Query: Get all the md5s from the database.</li>
						<li>For each md5 in the database, compute the similarity between the target MD5 and the ones in the database. This is done with a lighter version of the above query.</li>
						<li>For each of the results, compute the general similarity to be afle to output it into the interface.
					</ul>	
				   <b>To take note</b>: this version is not suitable for large datasets. Those datasets would need to be solved by scalled up version of this method. <br/>
				   This method speeds up things, enableling us to compute the 6 seconds query in under 1.
				</p>
			
			</section>			
		</section>



		<section typeof="sa:Conclusion">
			<h2>Conclusion</h2>
			<p>Through an ontology the connections between infected files are explored in depth, this provides valuable help and insight for malware analysis speeding up the process and finding new connections between malware samples.</p>
		</section>
	</article>
    
</body>
</html>