'use strict';

var sha256 = require('sha256')
var http = require('http')


exports.processFilePOST = function(args, res, next) {
  /**
   * File submission
   * Endpoint for submitting files for analysis.
   *
   * file File The file to be submitted. (optional)
   * email String Email to be accesed upon completion. (optional)
   * no response value expected for this operation
   **/
   if (args['email']['value']!='undefined')
	{
	var result = {
		hash: args['email']['value'],
		categories: new Array()
		};
	var mowl = 'http://www.semanticweb.org/acitea/ontologies/2017/0/malware-ontology#';
	var mowln = mowl.length;
	var md5s = new Array();
	getAllMd5s();
	//get categories
	}
	
	
	function getAllMd5s() {
		var sparqlCommand = `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX mowl: <http://www.semanticweb.org/acitea/ontologies/2017/0/malware-ontology#>
SELECT DISTINCT ?md5
WHERE {
     ?md5   rdf:type mowl:File
}
	`;
		sparqlCommand = encodeURIComponent(sparqlCommand);
		var sparql_ENDPOINT = 'http://46.101.240.170:8890/sparql?default-graph-uri=&query='+sparqlCommand+'&should-sponge=&format=application%2Fsparql-results%2Bjson&timeout=0';
		
		
		http.get(
			sparql_ENDPOINT
		, function(response) {
			// Continuously update stream with data
			var body = '';
			response.on('data', function(d) {
				body += d;
			});
			response.on('end', function() {
				
				// Data reception is done, do whatever with it!
				var parsed = JSON.parse(body);
				md5s = new Array();
				for (var i=0; i<parsed.results.bindings.length; i++)
					if (parsed.results.bindings[i].md5.value.substr(mowln)!=result.hash)
					md5s.push( {name: parsed.results.bindings[i].md5.value.substr(mowln), done:0, results: new Array()} );
				//console.log(md5s);
				getCategories();
			});
		});
	}
	
	function getCategories() {
		var sparqlCommand = `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	PREFIX owl: <http://www.w3.org/2002/07/owl#>
	PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
	PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
	PREFIX mowl: <http://www.semanticweb.org/acitea/ontologies/2017/0/malware-ontology#>
	SELECT DISTINCT ?target_subtype
	WHERE {
		 mowl:`+result.hash+`   ?p     ?target    .
		 
		 {
							?target     rdf:type   owl:Thing 
		 }
		 UNION
		 {
							?target     rdf:type   ?target_subtype .
							?target_subtype       rdfs:subClassOf     owl:Thing         
		 }
		 UNION
		 {
							?target     rdf:type   ?target_type .
							?target_type       rdfs:subClassOf        ?target_subtype .
							?target_subtype      rdfs:subClassOf         owl:Thing
		 }
		 UNION
		 { 
							 ?target     rdf:type   ?target_type .
							 ?target_type       rdfs:subClassOf        ?target_subsubtype .
							 ?target_subsubtype      rdfs:subClassOf         ?target_subtype .
							 ?target_subtype     rdfs:subClassOf      owl:Thing
		 }.
		 FILTER( ?target_subtype != mowl:File) 
	}
	`;
		sparqlCommand = encodeURIComponent(sparqlCommand);
		var sparql_ENDPOINT = 'http://46.101.240.170:8890/sparql?default-graph-uri=&query='+sparqlCommand+'&should-sponge=&format=application%2Fsparql-results%2Bjson&timeout=0';
		
		
		http.get(
			sparql_ENDPOINT
		, function(response) {
			// Continuously update stream with data
			var body = '';
			response.on('data', function(d) {
				body += d;
			});
			response.on('end', function() {
				
				// Data reception is done, do whatever with it!
				var parsed = JSON.parse(body);
				var categories = new Array();
				for (var i=0; i<parsed.results.bindings.length; i++)
					categories.push( {name: parsed.results.bindings[i].target_subtype.value.substr(mowln), done:0, md5results: new Array(md5s.length)  });
				result.categories = categories;
				for (var i=0; i<md5s.length; i++)
					md5s[i].results = new Array(categories.length);
				getCategoriesNumbers();
				getMd5CategoriesNumbers();
			});
		});
	}
	
	
	function getCategoriesNumbers() {
		for (var i=0; i<result.categories.length; i++)
			{
			for (var j=0; j<md5s.length; j++)
				{
					console.log(result.hash+' - '+md5s[j]+' - '+result.categories[i].name)
					var sparqlCommand = `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
					PREFIX owl: <http://www.w3.org/2002/07/owl#>
					PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
					PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
					PREFIX mowl: <http://www.semanticweb.org/acitea/ontologies/2017/0/malware-ontology#>
					SELECT  (COUNT (DISTINCT ?entity) AS $count) mowl:`+result.hash+` AS $mowl1 mowl:`+md5s[j].name+` AS $mowl2 mowl:`+result.categories[i].name+` as $category
					WHERE {
						 mowl:`+result.hash+`     ?prop    ?entity . 
						 mowl:`+md5s[j].name+`   ?prop    ?entity .
						 {
							?entity             rdf:type   mowl:`+result.categories[i].name+` 
							}
							UNION
							{
									?entity             rdf:type            ?entity_subtype .
									?entity_subtype     rdfs:subClassOf     mowl:`+result.categories[i].name+`         
							}
							UNION
							{
									?entity             rdf:type            ?entity_type .
									?entity_type        rdfs:subClassOf     ?entity_subtype .
									?entity_subtype     rdfs:subClassOf     mowl:`+result.categories[i].name+`
							}
							UNION
							{ 
									?entity                 rdf:type            ?entity_type .
									?entity_type            rdfs:subClassOf     ?entity_subtype .
									?entity_subtype         rdfs:subClassOf     ?entity_subsubtype .
									?entity_subsubtype      rdfs:subClassOf     mowl:`+result.categories[i].name+`
							} .
							FILTER(?entity != owl:NamedIndividual)
					}
						`;
					sparqlCommand = encodeURIComponent(sparqlCommand);
					var sparql_ENDPOINT = 'http://46.101.240.170:8890/sparql?default-graph-uri=&query='+sparqlCommand+'&should-sponge=&format=application%2Fsparql-results%2Bjson&timeout=0';
					
					
					http.get(
						sparql_ENDPOINT
					, function(response) {
						// Continuously update stream with data
						var body = '';
						response.on('data', function(d) {
							body += d;
						});
						response.on('end', function() {
							
							// Data reception is done, do whatever with it!
							var parsed = JSON.parse(body);
							var categ = parsed.results.bindings[0].category.value.substr(mowln);
							var categI = getCategoryIndex(categ);
							var md5I = getMd5Index(parsed.results.bindings[0].mowl2.value.substr(mowln))
							//categories.push( {name: parsed.results.bindings[i].target_subtype.value.substr(mowln), done:0, md5results: new Array(md5s.length)  });
							result.categories[categI].md5results[md5I] = parseFloat(parsed.results.bindings[0].count.value);
							result.categories[categI].done = isCategoryDone(result.categories[categI]);
							console.log(1);
							if (result.categories[categI].done)
								{
								if (AreAllDone())
									CalculatePercentagesAndGo();
								}
						});
					});
				}
			}
	}
	
	function getMd5CategoriesNumbers() {
		for (var i=0; i<md5s.length; i++)
			{
			for (var j=0; j<result.categories.length; j++)
				{
					
					var sparqlCommand = `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
					PREFIX owl: <http://www.w3.org/2002/07/owl#>
					PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
					PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
					PREFIX mowl: <http://www.semanticweb.org/acitea/ontologies/2017/0/malware-ontology#>
					SELECT  (COUNT (DISTINCT ?entity) AS $count) mowl:`+md5s[i].name+` AS $mowl1 mowl:`+result.categories[j].name+` as $category
					WHERE {
						 mowl:`+md5s[i].name+`     ?prop    ?entity . 
						 {
							?entity             rdf:type   mowl:`+result.categories[j].name+` 
							}
							UNION
							{
									?entity             rdf:type            ?entity_subtype .
									?entity_subtype     rdfs:subClassOf     mowl:`+result.categories[j].name+`         
							}
							UNION
							{
									?entity             rdf:type            ?entity_type .
									?entity_type        rdfs:subClassOf     ?entity_subtype .
									?entity_subtype     rdfs:subClassOf     mowl:`+result.categories[j].name+`
							}
							UNION
							{ 
									?entity                 rdf:type            ?entity_type .
									?entity_type            rdfs:subClassOf     ?entity_subtype .
									?entity_subtype         rdfs:subClassOf     ?entity_subsubtype .
									?entity_subsubtype      rdfs:subClassOf     mowl:`+result.categories[j].name+`
							} .
							FILTER(?entity != owl:NamedIndividual)
					}
						`;
					sparqlCommand = encodeURIComponent(sparqlCommand);
					var sparql_ENDPOINT = 'http://46.101.240.170:8890/sparql?default-graph-uri=&query='+sparqlCommand+'&should-sponge=&format=application%2Fsparql-results%2Bjson&timeout=0';
					
					
					http.get(
						sparql_ENDPOINT
					, function(response) {
						// Continuously update stream with data
						var body = '';
						response.on('data', function(d) {
							body += d;
						});
						response.on('end', function() {
							
							// Data reception is done, do whatever with it!
							var parsed = JSON.parse(body);
							var categ = parsed.results.bindings[0].category.value.substr(mowln);
							var categI = getCategoryIndex(categ);
							var md5I = getMd5Index(parsed.results.bindings[0].mowl1.value.substr(mowln))
							//categories.push( {name: parsed.results.bindings[i].target_subtype.value.substr(mowln), done:0, md5results: new Array(md5s.length)  });
							md5s[md5I].results[categI] = parseFloat(parsed.results.bindings[0].count.value);
							console.log(1);
							md5s[md5I].done = isMd5Done(md5s[md5I]);
							if (md5s[md5I].done)
								{
								if (AreAllDone())
									CalculatePercentagesAndGo();
								}
						});
					});
				}
			}
	}
	
	function CalculatePercentagesAndGo() {
		console.log(result.categories);
		console.log(md5s);
		for (var i=0; i<result.categories.length; i++)
			{
			result.categories[i].percents = new Array(md5s.length);
			var minpercent = 1001;
			for (var j=0; j<md5s.length; j++)
				{
				result.categories[i].percents[j] = parseFloat(parseFloat(result.categories[i].md5results[j]*100)/parseFloat(md5s[j].results[i]));
				
				if (result.categories[i].percents[j] <minpercent && !isNaN(result.categories[i].percents[j]))
					minpercent = result.categories[i].percents[j];
				if (isNaN(result.categories[i].percents[j]))
					result.categories[i].percents[j] = 0;
				}
			if (minpercent==1001)
				minpercent=0;
			result.categories[i].minpercent = minpercent;
			}
		res.end(JSON.stringify(result, null, 2));
		
	}
	
		
	function AreAllDone() {
		for (var i=0; i<result.categories.length; i++)
			if (result.categories[i].done==0)
				return 0;
		for (var i=0; i<md5s.length; i++)
			if (md5s[i].done==0)
				return 0;
		return 1;
	}
		
	function isMd5Done(md5) {
		for (var i=0; i<md5.results.length; i++)
			if (typeof(md5.results[i])=='undefined')
				return 0;
		return 1;
	}
	
	function isCategoryDone(categ) {
		for (var i=0; i<categ.md5results.length; i++)
			if (typeof(categ.md5results[i])=='undefined')
				return 0;
		return 1;
	}
	
	function getCategoryIndex(name) {
		for (var i=0; i<result.categories.length; i++)
			if (result.categories[i].name==name)
				return i;
		return 0;
	}
	
	function getMd5Index(name) {
		for (var i=0; i<md5s.length; i++)
			if (md5s[i].name==name)
				return i;
		return 0;
	}
	
  
  //console.log(sha256(args['file']['value']['buffer'].toString('utf8'))); 
  //res.end();
}

